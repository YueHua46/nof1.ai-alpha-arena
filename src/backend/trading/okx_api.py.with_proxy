"""
OKX exchange client implementation using CCXT.
Matches the interface required by the BotEngine.
"""

import asyncio
import logging
import ccxt.async_support as ccxt
from typing import Dict, List, Optional, Any
from src.backend.config_loader import CONFIG

class OKXAPI:
    """Facade around OKX CCXT client with convenience methods matching HyperliquidAPI interface."""

    def __init__(self):
        """Initialize OKX CCXT client."""
        self.api_key = CONFIG.get("okx_api_key")
        self.secret_key = CONFIG.get("okx_secret_key")
        self.passphrase = CONFIG.get("okx_passphrase")
        # flag: '0' for simulated trading, '1' for real trading
        self.flag = CONFIG.get("okx_flag", "0")

        if not all([self.api_key, self.secret_key, self.passphrase]):
            raise ValueError("Missing OKX credentials (OKX_API_KEY, OKX_SECRET_KEY, OKX_PASSPHRASE)")

        # Configure proxy if available (required for mainland China)
        proxy_config = {}
        http_proxy = CONFIG.get("http_proxy") or CONFIG.get("HTTP_PROXY")
        https_proxy = CONFIG.get("https_proxy") or CONFIG.get("HTTPS_PROXY")
        socks5_proxy = CONFIG.get("socks5_proxy") or CONFIG.get("SOCKS5_PROXY")
        
        if socks5_proxy:
            proxy_config['httpProxy'] = socks5_proxy
            proxy_config['httpsProxy'] = socks5_proxy
            logging.info(f"ğŸŒ ä½¿ç”¨ SOCKS5 ä»£ç†ï¼š{socks5_proxy}")
        elif https_proxy:
            proxy_config['httpProxy'] = https_proxy
            proxy_config['httpsProxy'] = https_proxy
            logging.info(f"ğŸŒ ä½¿ç”¨ HTTPS ä»£ç†ï¼š{https_proxy}")
        elif http_proxy:
            proxy_config['httpProxy'] = http_proxy
            proxy_config['httpsProxy'] = http_proxy
            logging.info(f"ğŸŒ ä½¿ç”¨ HTTP ä»£ç†ï¼š{http_proxy}")
        else:
            logging.warning("âš ï¸  æœªé…ç½®ä»£ç†ã€‚å¦‚æœåœ¨ä¸­å›½å¤§é™†ï¼ŒOKX å¯èƒ½æ— æ³•è®¿é—®ï¼")

        exchange_config = {
            'apiKey': self.api_key,
            'secret': self.secret_key,
            'password': self.passphrase,
            'timeout': 30000,  # 30 seconds timeout
            'enableRateLimit': True,  # Enable rate limiting
            'options': {
                'defaultType': 'swap',  # Target perpetual swaps by default
            }
        }
        
        # Add proxy if configured
        if proxy_config:
            exchange_config.update(proxy_config)
        
        self.exchange = ccxt.okx(exchange_config)

        if self.flag == '0':
            self.exchange.set_sandbox_mode(True)

        self.markets_loaded = False
        self._ct_val_cache: Dict[str, float] = {}
        self._position_mode: Optional[str] = None  # 'net_mode' or 'long_short_mode'
        
        logging.info(f"OKX å®¢æˆ·ç«¯ï¼ˆCCXTï¼‰åˆå§‹åŒ–å®Œæˆï¼ˆæ¨¡æ‹Ÿç›˜ï¼š{self.flag == '0'}ï¼‰")

    async def close(self):
        """Close the exchange connection."""
        await self.exchange.close()

    async def _ensure_markets(self):
        """Ensure markets are loaded with retry mechanism."""
        if not self.markets_loaded:
            max_retries = 3
            retry_delay = 5  # seconds
            
            for attempt in range(max_retries):
                try:
                    logging.info(f"ğŸ”„ åŠ è½½å¸‚åœºä¿¡æ¯... (å°è¯• {attempt + 1}/{max_retries})")
                    await self.exchange.load_markets()
                    self.markets_loaded = True
                    logging.info("âœ… å¸‚åœºä¿¡æ¯åŠ è½½æˆåŠŸ")
                    return
                except Exception as e:
                    error_msg = str(e)
                    if "Host is down" in error_msg or "Cannot connect" in error_msg or "Timeout" in error_msg:
                        logging.error(f"âŒ ç½‘ç»œè¿æ¥å¤±è´¥ (å°è¯• {attempt + 1}/{max_retries}): {error_msg}")
                        if attempt < max_retries - 1:
                            logging.info(f"â³ ç­‰å¾… {retry_delay} ç§’åé‡è¯•...")
                            await asyncio.sleep(retry_delay)
                            retry_delay *= 2  # Exponential backoff
                        else:
                            logging.error("âŒ æ— æ³•è¿æ¥åˆ° OKX æœåŠ¡å™¨ã€‚è¯·æ£€æŸ¥ï¼š")
                            logging.error("   1. ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸")
                            logging.error("   2. å¦‚æœåœ¨ä¸­å›½å¤§é™†ï¼Œè¯·é…ç½®ä»£ç†ï¼ˆ.env æ–‡ä»¶ä¸­çš„ HTTP_PROXY/HTTPS_PROXY/SOCKS5_PROXYï¼‰")
                            logging.error("   3. ä»£ç†è½¯ä»¶æ˜¯å¦æ­£å¸¸è¿è¡Œ")
                            raise ConnectionError(f"æ— æ³•è¿æ¥åˆ° OKX: {error_msg}") from e
                    else:
                        logging.error(f"åŠ è½½å¸‚åœºä¿¡æ¯å¤±è´¥: {e}")
                        raise

    def _get_symbol(self, asset: str) -> str:
        """Convert simple asset name to CCXT symbol (e.g. 'BTC' -> 'BTC/USDT:USDT')."""
        if "/" in asset:
            return asset
        return f"{asset}/USDT:USDT"

    def _get_inst_id(self, asset: str) -> str:
        """Convert simple asset name to OKX Instrument ID (e.g. 'BTC' -> 'BTC-USDT-SWAP')."""
        if "-SWAP" in asset:
            return asset
        return f"{asset}-USDT-SWAP"
    
    def _get_asset_from_symbol(self, symbol: str) -> str:
        """Extract simple asset name from CCXT symbol or InstId."""
        # "BTC/USDT:USDT" -> "BTC"
        # "BTC-USDT-SWAP" -> "BTC"
        if "/" in symbol:
            return symbol.split("/")[0]
        if "-USDT-SWAP" in symbol:
            return symbol.replace("-USDT-SWAP", "")
        return symbol

    async def _get_contract_value(self, symbol: str) -> float:
        """Get contract value (contractSize) from market info."""
        await self._ensure_markets()
        try:
            market = self.exchange.market(symbol)
            # For OKX swaps, 'contractSize' in CCXT usually represents the contract value (e.g. 1 contract = 0.01 BTC)
            # depending on the market.
            return float(market.get('contractSize', 1.0))
        except Exception as e:
            logging.error(f"Error fetching contract info for {symbol}: {e}")
            return 1.0
    
    async def _get_lot_size(self, symbol: str) -> float:
        """Get lot size (minimum size increment) from market info."""
        await self._ensure_markets()
        try:
            market = self.exchange.market(symbol)
            # OKX uses 'precision' dict with 'amount' field for lot size
            # Or 'limits' dict with 'amount' -> 'min' for minimum lot
            precision = market.get('precision', {})
            lot_size = precision.get('amount', 1.0)
            
            # If lot_size is None or 0, try to get from limits
            if not lot_size or lot_size == 0:
                limits = market.get('limits', {})
                amount_limits = limits.get('amount', {})
                lot_size = amount_limits.get('min', 1.0)
            
            # Fallback: for most OKX contracts, lot size is 1 or 0.1
            if not lot_size or lot_size == 0:
                lot_size = 1.0
                
            logging.debug(f"Lot size for {symbol}: {lot_size}")
            return float(lot_size)
        except Exception as e:
            logging.error(f"Error fetching lot size for {symbol}: {e}")
            return 1.0
    
    def _round_to_lot_size(self, quantity: float, lot_size: float) -> float:
        """Round quantity to nearest multiple of lot_size."""
        if lot_size <= 0:
            return quantity
        
        # Round to nearest lot size
        rounded = round(quantity / lot_size) * lot_size
        
        # Ensure at least 1 lot_size
        if rounded < lot_size:
            rounded = lot_size
            
        return rounded

    async def _ensure_position_mode(self) -> None:
        """Detect and cache OKX position mode (net / long_short)."""
        if self._position_mode is not None:
            return
        try:
            res = await self.exchange.private_get_account_config()
            data_list = res.get("data") or []
            data = data_list[0] if data_list else {}
            pos_mode = data.get("posMode")
            if pos_mode in ("net_mode", "long_short_mode"):
                self._position_mode = pos_mode
                logging.info(f"OKX æŒä»“æ¨¡å¼ï¼š{pos_mode}")
            else:
                self._position_mode = "net_mode"
                logging.warning(f"æœªèƒ½è¯†åˆ« OKX æŒä»“æ¨¡å¼ï¼Œé»˜è®¤ä½¿ç”¨ net_modeï¼š{data}")
        except Exception as e:
            # ä¿å®ˆé™çº§åˆ° net_modeï¼ˆä¸ä¼  posSideï¼‰
            self._position_mode = "net_mode"
            logging.error(f"è·å– OKX æŒä»“æ¨¡å¼å¤±è´¥ï¼Œå°†æŒ‰ net_mode å¤„ç†ï¼š{e}")

    async def get_user_state(self) -> Dict[str, Any]:
        """Retrieve wallet state and positions."""
        await self._ensure_markets()
        
        balance = 0.0
        total_equity = 0.0
        enriched_positions = []

        try:
            # 1. Get Balance
            # For OKX swap account, we look at the specific currency balance or total equity
            balance_data = await self.exchange.fetch_balance({'type': 'swap'})
            
            # CCXT structures balance: {'USDT': {'free': ..., 'used': ..., 'total': ...}, ...}
            # OKX often has 'info' with more details
            
            if 'USDT' in balance_data:
                balance = float(balance_data['USDT'].get('free', 0.0))
            
            # Try to get total equity from info if available (depends on account mode)
            # balance_data['info'] is the raw response from OKX
            if 'info' in balance_data and 'data' in balance_data['info']:
                data_list = balance_data['info']['data']
                if data_list and len(data_list) > 0:
                    total_equity = float(data_list[0].get('totalEq', 0.0))
            
            if total_equity == 0.0 and 'USDT' in balance_data:
                 # Fallback
                 total_equity = float(balance_data['USDT'].get('total', 0.0))

            # 2. Get Positions
            positions = await self.exchange.fetch_positions()
            
            for pos in positions:
                # pos structure normalized by CCXT
                symbol = pos['symbol'] # e.g. BTC/USDT:USDT
                asset = self._get_asset_from_symbol(symbol)
                
                contracts = float(pos['contracts']) if pos['contracts'] else 0.0
                if contracts == 0:
                    continue
                
                side = pos['side'] # 'long' or 'short'
                entry_px = float(pos['entryPrice'] or 0)
                mark_px = float(pos['markPrice'] or 0)
                upl = float(pos['unrealizedPnl'] or 0)
                leverage = float(pos['leverage'] or 1)
                liq_px = float(pos['liquidationPrice'] or 0)
                
                # OKX specific handling for size in coins
                # contracts * contractSize = amount in base currency (usually)
                contract_size = float(pos.get('contractSize', 1.0))
                size_coins = contracts * contract_size
                
                if side == 'short':
                    size_coins = -abs(size_coins)
                else:
                    size_coins = abs(size_coins)

                enriched_positions.append({
                    "symbol": asset,
                    "coin": asset,
                    "quantity": size_coins,
                    "entry_price": entry_px,
                    "current_price": mark_px,
                    "liquidation_price": liq_px,
                    "unrealized_pnl": upl,
                    "leverage": leverage,
                    "pnl": upl,
                    "szi": size_coins,
                    "entryPx": entry_px
                })

        except Exception as e:
            logging.error(f"Failed to fetch user state: {e}")

        return {
            "balance": balance,
            "total_value": total_equity,
            "positions": enriched_positions,
            "withdrawable": balance,
            "accountValue": total_equity,
            "assetPositions": [{"position": p} for p in enriched_positions]
        }

    async def get_current_price(self, asset: str) -> float:
        """Return the latest price for asset."""
        await self._ensure_markets()
        symbol = self._get_symbol(asset)
        try:
            ticker = await self.exchange.fetch_ticker(symbol)
            return float(ticker['last'])
        except Exception as e:
            logging.error(f"Error fetching price for {asset}: {e}")
            return 0.0

    async def place_buy_order(self, asset: str, amount: float, slippage: float = 0.01) -> Dict:
        """Submit a market buy order."""
        return await self._place_market_order(asset, 'buy', amount)

    async def place_sell_order(self, asset: str, amount: float, slippage: float = 0.01) -> Dict:
        """Submit a market sell order."""
        return await self._place_market_order(asset, 'sell', amount)

    async def _place_market_order(self, asset: str, side: str, amount: float) -> Dict:
        await self._ensure_markets()
        await self._ensure_position_mode()
        symbol = self._get_symbol(asset)
        
        # ===== Step 1: è·å–å½“å‰è´¦æˆ·ä½™é¢ =====
        try:
            balance_data = await self.exchange.fetch_balance({'type': 'swap'})
            usdt_free = float(balance_data.get('USDT', {}).get('free', 0.0))
            usdt_total = float(balance_data.get('USDT', {}).get('total', 0.0))
            
            # Try to get total equity from info
            total_equity = 0.0
            if 'info' in balance_data and 'data' in balance_data['info']:
                data_list = balance_data['info']['data']
                if data_list and len(data_list) > 0:
                    total_equity = float(data_list[0].get('totalEq', 0.0))
            
            if total_equity == 0.0:
                total_equity = usdt_total
            
            logging.info(f"ğŸ’° å½“å‰è´¦æˆ·ä½™é¢ - å¯ç”¨: ${usdt_free:,.2f} USDT | æ€»æƒç›Š: ${total_equity:,.2f} USDT")
        except Exception as e:
            logging.error(f"è·å–è´¦æˆ·ä½™é¢å¤±è´¥ï¼š{e}")
            # Continue anyway, let exchange handle insufficient balance error
        
        # ===== Step 2: è·å–å½“å‰ä»·æ ¼å¹¶è®¡ç®—USDTä»·å€¼ =====
        try:
            ticker = await self.exchange.fetch_ticker(symbol)
            current_price = float(ticker['last'])
            usdt_value = amount * current_price
            logging.info(f"ğŸ“Š {asset} å½“å‰ä»·æ ¼: ${current_price:,.2f}")
        except Exception as e:
            logging.error(f"è·å– {asset} å½“å‰ä»·æ ¼å¤±è´¥ï¼š{e}")
            raise e
        
        # ===== Step 3: è®¡ç®—åˆçº¦æ•°é‡ =====
        # OKX requires amount in contracts for swaps
        ct_val = await self._get_contract_value(symbol)
        
        # amount is in coins (e.g. 0.1 BTC)
        # contracts = amount / contract_value
        # OKX now supports fractional contracts (e.g. 0.1, 0.01) for some pairs
        # We retain up to 4 decimal places for safety, but rely on OKX to reject if too precise
        sz_contracts = float(amount / ct_val) if ct_val > 0 else 0.0
        
        # Simple check against 0, but actual min size limit is handled by exchange
        if sz_contracts <= 0.000001:
            logging.warning(f"Amount {amount} is too small for {symbol} (ctVal: {ct_val})")
            return {"code": "error", "msg": "Amount too small"}

        # ===== Step 4: æ‰“å°ä¸‹å•è¯¦æƒ… =====
        logging.info(f"ğŸ“ å‡†å¤‡ä¸‹ {side.upper()} å•ï¼š")
        logging.info(f"   æ ‡çš„: {symbol}")
        logging.info(f"   æ•°é‡: {amount:.6f} {asset}")
        logging.info(f"   ğŸ’µ ä»·å€¼: ${usdt_value:,.2f} USDT")
        logging.info(f"   åˆçº¦: {sz_contracts:.4f} å¼ ")
        logging.info(f"   åˆçº¦é¢å€¼: {ct_val} {asset}/å¼ ")
        
        # ===== Step 5: æ£€æŸ¥ä½™é¢æ˜¯å¦å……è¶³ï¼ˆè­¦å‘Šï¼Œä¸é˜»æ­¢ï¼‰ =====
        if usdt_free > 0 and usdt_value > usdt_free:
            logging.warning(f"âš ï¸  è­¦å‘Šï¼šä¸‹å•ä»·å€¼ ${usdt_value:,.2f} è¶…è¿‡å¯ç”¨ä½™é¢ ${usdt_free:,.2f}ï¼Œäº¤æ˜“æ‰€å¯èƒ½æ‹’ç»è®¢å•")
        
        # ===== Step 6: æ‰§è¡Œä¸‹å• =====
        try:
            # Use exchange-specific params for tdMode if needed, though CCXT defaultType='swap' usually handles it.
            # Passing 'tdMode': 'cross' explicitly to be safe.
            params: Dict[str, Any] = {'tdMode': 'cross'}
            # åœ¨é€ä»“å¤šç©ºåˆ†ç¦»æ¨¡å¼ä¸‹ï¼Œéœ€è¦æ˜¾å¼æä¾› posSide
            if self._position_mode == "long_short_mode":
                params["posSide"] = "long" if side == "buy" else "short"
            
            logging.info(f"ğŸš€ æ­£åœ¨æäº¤è®¢å•...")
            res = await self.exchange.create_order(symbol, 'market', side, sz_contracts, params=params)
            logging.info(f"âœ… è®¢å•æäº¤æˆåŠŸï¼è®¢å•ID: {res.get('id', 'N/A')}")
            return res
        except Exception as e:
            logging.error(f"âŒ ä¸‹å•å¤±è´¥ï¼š{e}")
            raise e

    async def place_take_profit(self, asset: str, is_buy: bool, amount: float, tp_price: float) -> Dict:
        """Place TP order using algo order."""
        await self._ensure_markets()
        await self._ensure_position_mode()
        inst_id = self._get_inst_id(asset)
        symbol = self._get_symbol(asset)
        
        ct_val = await self._get_contract_value(symbol)
        lot_size = await self._get_lot_size(symbol)
        
        # Calculate contracts
        sz_val = float(amount / ct_val) if ct_val > 0 else 0.0
        
        # Round to lot size for algo orders (OKX requirement)
        sz_val_rounded = self._round_to_lot_size(sz_val, lot_size)
        
        logging.info(f"ğŸ“Š æ­¢ç›ˆè®¢å•æ•°é‡è°ƒæ•´ï¼š{sz_val:.4f} â†’ {sz_val_rounded:.4f} å¼  (lotSz={lot_size})")
        
        # Format with appropriate precision
        # Use integer format if lot_size is 1, otherwise use decimal
        if lot_size >= 1:
            sz_contracts = str(int(sz_val_rounded))
        else:
            # Count decimal places in lot_size
            decimals = len(str(lot_size).split('.')[-1]) if '.' in str(lot_size) else 0
            sz_contracts = f"{sz_val_rounded:.{decimals}f}"
        
        side = "sell" if is_buy else "buy"
        
        # Use private API directly to ensure correct OKX algo order params
        params: Dict[str, Any] = {
            'instId': inst_id,
            'tdMode': 'cross',
            'side': side,
            'ordType': 'conditional',
            'sz': sz_contracts,
            'tpTriggerPx': str(tp_price),
            'tpOrdPx': '-1'  # Market price when triggered
        }
        # long_short_mode ä¸‹éœ€è¦æŒ‡å®š posSideï¼ˆä»¥åŸå§‹æŒä»“æ–¹å‘ä¸ºå‡†ï¼‰
        if self._position_mode == "long_short_mode":
            params["posSide"] = "long" if is_buy else "short"
        
        try:
            return await self.exchange.private_post_trade_order_algo(params)
        except Exception as e:
            logging.error(f"Error placing TP: {e}")
            raise e

    async def place_stop_loss(self, asset: str, is_buy: bool, amount: float, sl_price: float) -> Dict:
        """Place SL order using algo order."""
        await self._ensure_markets()
        await self._ensure_position_mode()
        inst_id = self._get_inst_id(asset)
        symbol = self._get_symbol(asset)
        
        ct_val = await self._get_contract_value(symbol)
        lot_size = await self._get_lot_size(symbol)
        
        # Calculate contracts
        sz_val = float(amount / ct_val) if ct_val > 0 else 0.0
        
        # Round to lot size for algo orders (OKX requirement)
        sz_val_rounded = self._round_to_lot_size(sz_val, lot_size)
        
        logging.info(f"ğŸ“Š æ­¢æŸè®¢å•æ•°é‡è°ƒæ•´ï¼š{sz_val:.4f} â†’ {sz_val_rounded:.4f} å¼  (lotSz={lot_size})")
        
        # Format with appropriate precision
        if lot_size >= 1:
            sz_contracts = str(int(sz_val_rounded))
        else:
            decimals = len(str(lot_size).split('.')[-1]) if '.' in str(lot_size) else 0
            sz_contracts = f"{sz_val_rounded:.{decimals}f}"
        
        side = "sell" if is_buy else "buy"
        
        params: Dict[str, Any] = {
            'instId': inst_id,
            'tdMode': 'cross',
            'side': side,
            'ordType': 'conditional',
            'sz': sz_contracts,
            'slTriggerPx': str(sl_price),
            'slOrdPx': '-1'  # Market price when triggered
        }
        if self._position_mode == "long_short_mode":
            params["posSide"] = "long" if is_buy else "short"
        
        try:
            return await self.exchange.private_post_trade_order_algo(params)
        except Exception as e:
            logging.error(f"Error placing SL: {e}")
            raise e

    async def cancel_order(self, asset: str, oid: str) -> Dict:
        """Cancel an order (regular or algo)."""
        await self._ensure_markets()
        symbol = self._get_symbol(asset)
        inst_id = self._get_inst_id(asset)
        
        # Try cancelling as regular order first
        try:
            return await self.exchange.cancel_order(oid, symbol)
        except Exception:
            # If not found or error, try cancelling as algo order
            try:
                return await self.exchange.private_post_trade_cancel_algo_order([{'instId': inst_id, 'algoId': oid}])
            except Exception as e:
                logging.error(f"Error cancelling order {oid}: {e}")
                return {"code": "error", "msg": str(e)}

    async def cancel_all_orders(self, asset: str) -> Dict:
        """Cancel all open orders for asset."""
        await self._ensure_markets()
        symbol = self._get_symbol(asset)
        inst_id = self._get_inst_id(asset)
        
        try:
            # 1. Regular orders
            # CCXT cancel_all_orders implementation for OKX usually works well
            await self.exchange.cancel_all_orders(symbol)
            
            # 2. Algo orders (fetch pending then cancel)
            # Need to use private API to find pending algo orders
            algo_orders_res = await self.exchange.private_get_trade_orders_algo_pending({'instType': 'SWAP', 'instId': inst_id})
            if algo_orders_res.get('code') == '0' and algo_orders_res.get('data'):
                algo_ids = [{'instId': inst_id, 'algoId': o['algoId']} for o in algo_orders_res['data']]
                if algo_ids:
                    await self.exchange.private_post_trade_cancel_algo_order(algo_ids)
            
            return {"status": "ok"}
        except Exception as e:
            logging.error(f"Error cancelling all orders: {e}")
            return {"status": "error", "msg": str(e)}

    async def get_open_orders(self) -> List[Dict]:
        """Get all open orders (regular and algo)."""
        await self._ensure_markets()
        orders = []
        
        try:
            # 1. Regular orders using Raw API to get all SWAP orders at once
            # (CCXT fetchOpenOrders might require symbol or multiple calls)
            res = await self.exchange.private_get_trade_orders_pending({'instType': 'SWAP'})
            if res.get('code') == '0':
                for o in res.get('data', []):
                    inst_id = o['instId']
                    symbol = self._get_symbol(self._get_asset_from_symbol(inst_id))
                    
                    ct_val = await self._get_contract_value(symbol)
                    sz_contracts = float(o.get('sz', 0))
                    size_coins = sz_contracts * ct_val
                    
                    orders.append({
                        "coin": self._get_asset_from_symbol(inst_id),
                        "oid": o["ordId"],
                        "is_buy": o["side"] == "buy",
                        "size": size_coins,
                        "price": float(o.get("px", 0) or 0),
                        "trigger_price": None,
                        "order_type": o["ordType"]
                    })
            
            # 2. Algo orders
            res_algo = await self.exchange.private_get_trade_orders_algo_pending({'instType': 'SWAP', 'ordType': 'conditional'})
            if res_algo.get('code') == '0':
                 for o in res_algo.get('data', []):
                    inst_id = o['instId']
                    symbol = self._get_symbol(self._get_asset_from_symbol(inst_id))
                    
                    ct_val = await self._get_contract_value(symbol)
                    sz_contracts = float(o.get('sz', 0))
                    size_coins = sz_contracts * ct_val
                    
                    trigger_px = o.get("tpTriggerPx") or o.get("slTriggerPx")
                    orders.append({
                        "coin": self._get_asset_from_symbol(inst_id),
                        "oid": o["algoId"],
                        "is_buy": o["side"] == "buy",
                        "size": size_coins,
                        "price": float(o.get("ordPx", 0) or -1),
                        "trigger_price": float(trigger_px) if trigger_px else None,
                        "order_type": "trigger"
                    })

        except Exception as e:
            logging.error(f"Error fetching open orders: {e}")
            
        return orders

    async def get_recent_fills(self, limit: int = 50) -> List[Dict]:
        """Get recent trades."""
        await self._ensure_markets()
        fills = []
        try:
            # Use raw API to get fills for all swaps
            res = await self.exchange.private_get_trade_fills({'instType': 'SWAP', 'limit': str(limit)})
            if res.get('code') == '0':
                for f in res.get('data', []):
                    inst_id = f['instId']
                    symbol = self._get_symbol(self._get_asset_from_symbol(inst_id))
                    
                    ct_val = await self._get_contract_value(symbol)
                    sz_contracts = float(f.get('sz', 0))
                    size_coins = sz_contracts * ct_val
                    
                    fills.append({
                        "timestamp": f.get("ts"),
                        "coin": self._get_asset_from_symbol(inst_id),
                        "is_buy": f["side"] == "buy",
                        "size": size_coins,
                        "price": float(f.get("fillPx", 0))
                    })
        except Exception as e:
            logging.error(f"Error fetching fills: {e}")
            
        return fills

    def extract_oids(self, order_result: Dict) -> List[str]:
        """Extract Order IDs from response."""
        oids = []
        # CCXT normalized 'id'
        if 'id' in order_result:
            oids.append(order_result['id'])
        
        # Check raw 'data' if it's a direct API response structure
        # (CCXT create_order returns a dict that includes 'info' with raw data)
        if 'info' in order_result and isinstance(order_result['info'], dict):
             raw_data = order_result['info'].get('data', [])
             if raw_data:
                 for d in raw_data:
                     if 'ordId' in d:
                         oids.append(d['ordId'])
                     if 'algoId' in d:
                         oids.append(d['algoId'])

        # Fallback: if order_result is just the raw OKX response dict (not CCXT structure)
        if order_result.get("code") == "0" and order_result.get("data"):
            for d in order_result["data"]:
                if "ordId" in d:
                    oids.append(d["ordId"])
                if "algoId" in d:
                    oids.append(d["algoId"])
                    
        # Deduplicate
        return list(set(oids))

    async def get_open_interest(self, asset: str) -> Optional[float]:
        """Get Open Interest."""
        await self._ensure_markets()
        symbol = self._get_symbol(asset)
        try:
            res = await self.exchange.fetch_open_interest(symbol)
            return float(res.get('openInterestAmount', 0)) # or res['openInterest'] depending on CCXT version normalization
        except Exception:
            return None

    async def get_funding_rate(self, asset: str) -> Optional[float]:
        """Get Funding Rate."""
        await self._ensure_markets()
        symbol = self._get_symbol(asset)
        try:
            res = await self.exchange.fetch_funding_rate(symbol)
            return float(res.get('fundingRate', 0))
        except Exception:
            return None
